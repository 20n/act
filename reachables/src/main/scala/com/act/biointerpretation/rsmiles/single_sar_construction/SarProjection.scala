package com.act.biointerpretation.rsmiles.single_sar_construction

import java.io._
import java.util

import chemaxon.formats.MolFormatException
import chemaxon.marvin.io.MolExportException
import chemaxon.reaction.Reactor
import chemaxon.struc.Molecule
import com.act.analysis.chemicals.molecules.{MoleculeExporter, MoleculeFormat, MoleculeImporter}
import com.act.utils.{CLIUtil, TSVParser, TSVWriter}
import org.apache.commons.cli.{CommandLine, Option => CliOption}

import scala.collection.JavaConverters._
import scala.collection.mutable

object SarProjection {
  val OPTION_SAR_FILE = "s"
  val OPTION_CHEMICALS_FILE = "c"
  val OPTION_OUTPUT_FILE = "o"
  
  private val HELP_MESSAGE: String =
    """
      | Used to generate L3 projections based on SARs and input chemicals.
    """.stripMargin
  
  val OPTION_BUILDERS: util.List[CliOption.Builder] = List(
    CliOption.builder(OPTION_SAR_FILE).
      argName("sar-file").
      desc("The SAR file generated by SingleSarsReactionPipeline").
      hasArg.
      required.
      longOpt("sar-file"),

    CliOption.builder(OPTION_CHEMICALS_FILE).
      argName("chemicals-file").
      desc("An input file containing just InChIs, one per line.").
      hasArg.
      required.
      longOpt("chemicals-file"),

    CliOption.builder(OPTION_OUTPUT_FILE).
      argName("output-file").
      desc("Output TSV file path.").
      hasArg.
      required.
      longOpt("output-file")
  ).asJava

  def main(args: Array[String]): Unit = {
    // CLI Parsing
    val cliUtil: CLIUtil = new CLIUtil(getClass, HELP_MESSAGE, OPTION_BUILDERS)
    val cl: CommandLine = cliUtil.parseCommandLine(args)
    
    val sarsFile = new File(cl.getOptionValue(OPTION_SAR_FILE))
    val chemicalsFile = new File(cl.getOptionValue(OPTION_CHEMICALS_FILE))
    val outputFile = new File(cl.getOptionValue(OPTION_OUTPUT_FILE))
    
    // Read in the prior SAR file
    val sarsReader = new TSVParser()
    sarsReader.parse(sarsFile)

    // Gets the reactors from the file
    val reactors = sarsReader.getResults.asScala.flatMap(getReactor)

    val chemicalReader = new BufferedReader(new FileReader(chemicalsFile))

    var nextLine : Option[String] = None

    def getNextChemicalString(): Boolean = {
      nextLine = Option(chemicalReader.readLine())
      nextLine.isDefined
    }

    val results : mutable.ListBuffer[(String, String, String)] = new mutable.ListBuffer[(String, String, String)]

    // Iterate over chemicals in input
    while (getNextChemicalString()) {
      try {
        val chemical = MoleculeImporter.importMolecule(nextLine.get.trim, MoleculeFormat.inchi)
        val substrates = Array(chemical)

        // Iterate over reactors
        for (reactor <- reactors) {
          reactor.setReactants(substrates)

          var products: Option[Array[Molecule]] = None

          def reactReactor(): Boolean = {
            products = Option(reactor.react())
            products.isDefined
          }

          while (reactReactor()) {
              results.append((nextLine.get.trim, MoleculeExporter.exportAsStdInchi(products.get.head), MoleculeExporter.exportAsSmarts(reactor.getReaction)))
          }
        }
      }
      catch {
        // Exceptions have happened on due to too many atoms and bad input strings. Print error, but continue!
        case formatException: MolFormatException => println(s"Couldn't import ${nextLine.get.trim}. ${formatException.getMessage}")
        case exportException : MolExportException => println(s"Couldn't export molecules for input ${nextLine.get.trim}. ${exportException.getMessage}")
      }
    }

    // Write output to TSV file, one line per projection
    val substrateHeader = "SUBSTRATE"
    val productHeader = "PRODUCT"
    val sarHeader = "SAR"
    val headers = List(substrateHeader, productHeader, sarHeader).asJava
     val writer = new TSVWriter[String, String](headers)
    writer.open(outputFile)
    results.foreach(element => {
      val row : java.util.Map[String, String] = new util.HashMap[String, String]()
      row.put(substrateHeader, element._1)
      row.put(productHeader, element._2)
      row.put(sarHeader, element._3)
      writer.append(row)
    })
    writer.flush()
  }

  // Gets a reactor object from a row of the TSV reader. THe only relevant header is the SAR header
  def getReactor(row: java.util.Map[String, String]): Option[Reactor] = {
    val SAR_HEADER = "SAR"

    // SARs may not be present in every row. Wherever one is present, make it into a reactor
    if (!row.get(SAR_HEADER).trim().isEmpty) {
      val reactor = new Reactor
      reactor.setReactionString(row.get(SAR_HEADER))
      Some(reactor)
    } else {
      None
    }
  }
}
