package com.act.biointerpretation.rsmiles.single_sar_construction

import java.io._
import java.util

import chemaxon.formats.MolFormatException
import chemaxon.marvin.io.MolExportException
import chemaxon.reaction.Reactor
import chemaxon.struc.Molecule
import com.act.analysis.chemicals.molecules.{MoleculeExporter, MoleculeFormat, MoleculeImporter}
import com.act.utils.{TSVParser, TSVWriter}

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Used to generate L3 projections based on SARs and input chemicals.
  */
object SarProjection {

  // TODO: Obviously these should be command line args
  // sars file is as generated by SingleSarsReactionPipeline
  val sarsFile = new File("/mnt/shared-data/Gil/abstract_reactions/sars.tsv")
  // One inchi per line
  val chemicalsFile = new File("/mnt/shared-data/Gil/abstract_reactions/prediction_seed")
  // TSV file with three headers: SUBSTRATE PRODUCT SAR
  val outputFile = new File("/mnt/shared-data/Gil/abstract_reactions/predictions.tsv")

  def main(args: Array[String]): Unit = {
    val sarsReader = new TSVParser()
    sarsReader.parse(sarsFile)

    // Gets the reactors from the file
    val reactors = sarsReader.getResults.asScala.flatMap(getReactor)

    val chemicalReader = new BufferedReader(new FileReader(chemicalsFile))

    var nextLine : Option[String] = None

    def getNextChemicalString() : Boolean = {
      nextLine = Option(chemicalReader.readLine())
      nextLine.isDefined
    }

    var count = 0

    var results : mutable.ListBuffer[(String, String, String)] = new mutable.ListBuffer[(String, String, String)]

    // Iterate over chemicals in input
    while (getNextChemicalString()) {
      try {
        val chemical = MoleculeImporter.importMolecule(nextLine.get.trim, MoleculeFormat.inchi)
        val substrates = Array(chemical)

        // Iterate over reactors
        for (reactor <- reactors) {
          reactor.setReactants(substrates)

          var products: Option[Array[Molecule]] = None

          def reactReactor(): Boolean = {
            products = Option(reactor.react())
            products.isDefined
          }

          while (reactReactor()) {
              results.append((nextLine.get.trim, MoleculeExporter.exportAsStdInchi(products.get.head), MoleculeExporter.exportAsSmarts(reactor.getReaction)))
          }
        }
      }
      catch {
        // Exceptions have happened on due to too many atoms and bad input strings. Print error, but continue!
        case formatException: MolFormatException => println(s"Couldn't import ${nextLine.get.trim}. ${formatException.getMessage}")
        case exportException : MolExportException => println(s"Couldn't export molecules for input ${nextLine.get.trim}. ${exportException.getMessage}")
      }
      count = count + 1
      if (count % 100 == 0) {
        println(s"Processed $count chemicals.")
      }
    }

    // Write output to TSV file, one line per projection
    val substrateHeader = "SUBSTRATE"
    val productHeader = "PRODUCT"
    val sarHeader = "SAR"
    val headers = List(substrateHeader, productHeader, sarHeader).asJava
     val writer = new TSVWriter[String, String](headers)
    writer.open(outputFile)
    results.foreach(element => {
      val row : java.util.Map[String, String] = new util.HashMap[String, String]()
      row.put(substrateHeader, element._1)
      row.put(productHeader, element._2)
      row.put(sarHeader, element._3)
      writer.append(row)
    })
    writer.flush()
  }

  // Gets a reactor object from a row of the TSV reader. THe only relevant header is the SAR header
  def getReactor(row: java.util.Map[String, String]): Option[Reactor] = {
    val sarHeader = "SAR"

    // SARs may not be present in every row. Wherever one is present, make it into a reactor
    if (!row.get("SAR").trim().isEmpty) {
      val reactor = new Reactor
      reactor.setReactionString(row.get("SAR"))
      return Some(reactor)
    }
    None
  }
}
