package com.act.lcms.db;

import org.apache.commons.lang3.StringUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public abstract class PlateWell<T extends PlateWell> {

  // These should be static, but static and abstract are incompatible! :(
  public abstract String getTableName();
  public abstract List<String> getAllFields();
  public abstract List<String> getInsertUpdateFields();
  protected abstract List<T> fromResultSet(ResultSet resultSet) throws SQLException;

  protected List<String> makeInsertUpdateFields() {
    List<String> allFields = getAllFields();
    return Collections.unmodifiableList(allFields.subList(1, allFields.size()));
  }

  protected String makeGetByIDQuery() {
    return StringUtils.join(new String[]{
        "SELECT", StringUtils.join(getAllFields(), ','),
        "from", getTableName(),
        "where id = ?",
    }, " ");
  }
  protected abstract String getGetByIDQuery();
  public T getById(DB db, Integer id) throws SQLException {
    try (PreparedStatement stmt = db.getConn().prepareStatement(getGetByIDQuery())) {
      stmt.setInt(1, id);
      try (ResultSet resultSet = stmt.executeQuery()) {
        return expectOneResult(resultSet, String.format("id = %d", id));
      }
    }
  }

  protected String makeGetByPlateIDQuery() {
    return StringUtils.join(new String[] {
        "SELECT", StringUtils.join(this.getAllFields(), ','),
        "from", this.getTableName(),
        "where plate_id = ?",
        "order by plate_row asc, plate_column asc"
    }, " ");
  }
  protected abstract String getGetByPlateIDQuery();
  public List<T> getByPlateId(DB db, Integer plateId) throws SQLException {
    try (PreparedStatement stmt = db.getConn().prepareStatement(getGetByPlateIDQuery())) {
      stmt.setInt(1, plateId);
      try (ResultSet resultSet = stmt.executeQuery()) {
        return fromResultSet(resultSet);
      }
    }
  }

  /**
   * Important: use this only when building constants to avoid the risk of SQL injection attacks.
   * @param field The field to select.
   * @return A query that binds a value to the specified field in a `WHERE` clause .
   */
  protected String makeGetQueryForSelectField(String field) {
    return StringUtils.join(new String[] {
        "SELECT", StringUtils.join(this.getAllFields(), ','),
        "from", this.getTableName(),
        String.format("where %s = ?", field),
    }, " ");
  }

  public abstract String getInsertQuery();
  protected String makeInsertQuery() {
    List<String> parameters = new ArrayList<>(getInsertUpdateFields().size());
    for (String field : getInsertUpdateFields()) {
      parameters.add("?");
    }
    return StringUtils.join(new String[] {
        "INSERT INTO", getTableName(), "(", StringUtils.join(getInsertUpdateFields(), ", "), ") VALUES (",
        StringUtils.join(parameters, ", "),
        ")",
    }, " ");
  }

  public abstract String getUpdateQuery();
  protected String makeUpdateQuery() {
    List<String> parameters = new ArrayList<>(getInsertUpdateFields().size());
    for (String field : getInsertUpdateFields()) {
      parameters.add(String.format("%s = ?", field));
    }
    return StringUtils.join(new String[] {
        "UPDATE ", getTableName(), "SET",
        StringUtils.join(parameters, ", "),
        "WHERE",
        "id = ?",
    }, " ");
  }

  protected abstract void bindInsertOrUpdateParameters(PreparedStatement stmt, T parameterSource) throws SQLException;
  protected T insert(DB db, T toInsert) throws SQLException {
    Connection conn = db.getConn();
    try (PreparedStatement stmt = conn.prepareStatement(getInsertQuery(), Statement.RETURN_GENERATED_KEYS)) {
      bindInsertOrUpdateParameters(stmt, toInsert);
      stmt.executeUpdate();
      try (ResultSet resultSet = stmt.getGeneratedKeys()) {
        if (resultSet.next()) {
          // Get auto-generated id.
          int id = resultSet.getInt(1);
          toInsert.setId(id);
          return toInsert;
        } else {
          // TODO: log error here.
          System.err.format("ERROR: could not retrieve autogenerated key for well at %d @ %d x %d\n",
              plateId, plateRow, plateColumn);
          return null;
        }
      }
    }
  }

  public boolean update(DB db, T toUpdate) throws SQLException {
    Connection conn = db.getConn();
    try (PreparedStatement stmt = conn.prepareStatement(getUpdateQuery())) {
      bindInsertOrUpdateParameters(stmt, toUpdate);
      stmt.setInt(getInsertUpdateFields().size() + 1, toUpdate.getId());
      return stmt.executeUpdate() > 0;
    }
  }

  protected T expectOneResult(ResultSet resultSet, String queryErrStr) throws SQLException{
    List<T> results = this.fromResultSet(resultSet);
    if (results.size() > 1) {
      throw new SQLException("Found multiple results where one or zero expected: %s", queryErrStr);
    }
    if (results.size() == 0) {
      return null;
    }
    return results.get(0);
  }

  /* Use protected rather than private, as this class represents common attributes of all plate wells.  Extending
   * classes can/should have access to its fields, as its existence is simply an organizational convenience. */
  protected Integer id;
  protected Integer plateId;
  protected Integer plateRow;
  protected Integer plateColumn;

  public Integer getId() {
    return id;
  }

  protected void setId(Integer id) {
    this.id = id;
  }

  public Integer getPlateId() {
    return plateId;
  }

  public void setPlateId(Integer plateId) {
    this.plateId = plateId;
  }

  public Integer getPlateRow() {
    return plateRow;
  }

  public void setPlateRow(Integer plateRow) {
    this.plateRow = plateRow;
  }

  public Integer getPlateColumn() {
    return plateColumn;
  }

  public void setPlateColumn(Integer plateColumn) {
    this.plateColumn = plateColumn;
  }

  public String getCoordinatesString() {
    if (plateRow == null || plateColumn == null) {
      return "(unknown)";
    }
    return String.format("%s%d",
        Character.valueOf((char) (this.getPlateRow() + 'A')).toString(), this.getPlateColumn() + 1);
  }
}
